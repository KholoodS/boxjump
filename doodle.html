<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Doodle Jump (Vanilla JS)</title>
  <style>
    :root{
      --bg1:#0f172a; /* slate-900 */
      --bg2:#1e293b; /* slate-800 */
      --accent:#22d3ee; /* cyan-400 */
      --accent2:#a78bfa; /* violet-400 */
      --good:#34d399; /* emerald-400 */
      --warn:#f59e0b; /* amber-500 */
      --bad:#ef4444; /* red-500 */
      --ink:#e2e8f0; /* slate-200 */
    }
    html,body{height:100%;}
    body{
      margin:0; display:flex; align-items:center; justify-content:center; 
      background: radial-gradient(1200px 800px at 30% -10%, #111827 0%, var(--bg1) 45%, #020617 100%);
      color:var(--ink); font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      overflow:hidden;
    }
    .frame{
      position:relative; width:min(100vw, 540px); height:min(100vh, 960px);
      aspect-ratio: 9/16; box-shadow: 0 30px 80px rgba(0,0,0,.5);
      border-radius:20px; overflow:hidden; background:linear-gradient(180deg, #0b1220, #0b1220);
      border:1px solid rgba(255,255,255,.06);
    }
    canvas{ width:100%; height:100%; display:block; background:linear-gradient(180deg, #0ea5e9 0%, #60a5fa 35%, #93c5fd 100%); }

    .hud{ position:absolute; inset:0; pointer-events:none; }
    .score{ position:absolute; top:12px; left:12px; background:rgba(2,6,23,.55); border:1px solid rgba(255,255,255,.09); padding:8px 12px; border-radius:14px; font-weight:700; letter-spacing:.5px;}
    .buttons{ position:absolute; top:12px; right:12px; display:flex; gap:8px; }
    .btn{ pointer-events:auto; border:none; padding:10px 14px; border-radius:14px; background:rgba(2,6,23,.7); color:var(--ink); font-weight:700; cursor:pointer; border:1px solid rgba(255,255,255,.1); transition:transform .06s ease; }
    .btn:hover{ transform:translateY(-1px); }

    .overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(2,6,23,.6); backdrop-filter: blur(6px); pointer-events:auto; }
    .card{ background:rgba(15,23,42,.9); border:1px solid rgba(255,255,255,.08); padding:22px; border-radius:18px; text-align:center; width:min(85%, 420px); }
    .title{ font-size:28px; font-weight:800; margin:0 0 6px; }
    .subtitle{ opacity:.85; margin:0 0 16px; }

    /* Touch controls */
    .touchpad{ position:absolute; inset:0; display:flex; }
    .zone{ flex:1; pointer-events:auto; }
    .zone.left{ background:linear-gradient(90deg, rgba(2,6,23,.18), rgba(2,6,23,0)); }
    .zone.right{ background:linear-gradient(270deg, rgba(2,6,23,.18), rgba(2,6,23,0)); }

    /* Help footer */
    .help{ position:absolute; bottom:10px; left:50%; transform:translateX(-50%); font-size:12px; opacity:.9; background:rgba(2,6,23,.5); border:1px solid rgba(255,255,255,.08); padding:6px 10px; border-radius:12px; }
  </style>
</head>
<body>
  <div class="frame">
    <canvas id="game" width="540" height="960"></canvas>
    <div class="hud">
      <div class="score">Score: <span id="scoreVal">0</span></div>
      <div class="buttons">
        <button class="btn" id="pauseBtn">Pause ‚è∏Ô∏è</button>
        <button class="btn" id="restartBtn">Restart üîÑ</button>
      </div>
      <div class="help">Keyboard: ‚Üê ‚Üí or A/D ‚Ä¢ Mobile: tap left/right ‚Ä¢ Wraps at edges</div>
    </div>
    <div class="touchpad" id="touchpad" aria-hidden="true">
      <div class="zone left" id="leftZone"></div>
      <div class="zone right" id="rightZone"></div>
    </div>
    <div class="overlay" id="overlay" style="display:none">
      <div class="card">
        <h2 class="title" id="ovTitle">Paused</h2>
        <p class="subtitle" id="ovSubtitle">Press Resume to keep jumping!</p>
        <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
          <button class="btn" id="resumeBtn">Resume ‚ñ∂Ô∏è</button>
          <button class="btn" id="ovRestartBtn">Restart üîÑ</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // --- Resize canvas to match CSS size (while keeping internal resolution crisp)
    function fitCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    // --- Game constants
    const G = 2200; // gravity px/s^2
    const JUMP_V = 1100; // bounce velocity px/s
    const MOVE_ACCEL = 3000; // horiz accel
    const MOVE_MAX = 420; // max horiz speed

    const PLATFORM_GAP_MIN = 85;
    const PLATFORM_GAP_MAX = 130;

    const state = {
      player:{x:100,y:0,w:44,h:44,vx:0,vy:0},
      platforms:[],
      cameraY:0, // world y at top of screen
      maxHeight:0, // highest negative cameraY reached
      gameOver:false,
      paused:false,
      started:false,
      input:{left:false,right:false},
      lastTime:performance.now()
    };

    // Utility RNG
    const rand = (a,b)=> a + Math.random()*(b-a);
    const randi = (a,b)=> Math.floor(rand(a,b+1));

    function reset(){
      state.platforms = [];
      state.cameraY = 0;
      state.maxHeight = 0;
      state.gameOver = false;
      state.paused = false;
      state.started = false;

      // Place player
      state.player.x = canvas.width/2/ (window.devicePixelRatio||1);
      state.player.y = -60;
      state.player.vx = 0; state.player.vy = -JUMP_V*0.9; // initial upward burst

      // Create starting platforms up to top
      spawnInitialPlatforms();
      updateScoreUI();
    }

    function spawnInitialPlatforms(){
      // base ground platform
      state.platforms.push(makePlatform(canvas.width*0.5 - 60, 10, 120, 18, 'static'));

      let y = -70; // a bit above ground
      const top = -2000; // generate up a couple screens
      while(y > top){
        y -= rand(PLATFORM_GAP_MIN, PLATFORM_GAP_MAX);
        const w = rand(70, 130);
        const x = rand(8, canvas.width/(window.devicePixelRatio||1) - w - 8);
        const type = Math.random()<0.18 ? 'moving' : 'static';
        state.platforms.push(makePlatform(x, y, w, 16, type));
      }
    }

    function extendPlatformsIfNeeded(){
      // Ensure platforms exist above current camera by ~3 screens
      const targetTop = state.cameraY - canvas.height/(window.devicePixelRatio||1) * 3;
      let highest = Math.min(...state.platforms.map(p=>p.y));
      let y = highest;
      while(y > targetTop){
        y -= rand(PLATFORM_GAP_MIN, PLATFORM_GAP_MAX);
        const w = rand(70, 130);
        const x = rand(8, canvas.width/(window.devicePixelRatio||1) - w - 8);
        const r = Math.random();
        let type = 'static';
        if(r < 0.15) type = 'moving';
        else if(r < 0.20) type = 'fragile';
        state.platforms.push(makePlatform(x,y,w,16,type));
      }

      // Remove platforms far below camera
      const cutoff = state.cameraY + canvas.height/(window.devicePixelRatio||1) + 200;
      state.platforms = state.platforms.filter(p=> p.y < cutoff);
    }

    function makePlatform(x,y,w,h,type){
      return {x,y,w,h,type,dx: (type==='moving'? (Math.random()<0.5?-1:1) * rand(40,80):0), broken:false};
    }

    // INPUT
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{
      if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A'){ state.input.left=true; state.started=true; }
      if(e.key==='ArrowRight'|| e.key==='d' || e.key==='D'){ state.input.right=true; state.started=true; }
      if(e.key===' ' && state.gameOver){ reset(); }
      if(e.key==='p' || e.key==='P'){ togglePause(); }
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A'){ state.input.left=false; }
      if(e.key==='ArrowRight'|| e.key==='d' || e.key==='D'){ state.input.right=false; }
    });

    // Touch controls
    const leftZone = document.getElementById('leftZone');
    const rightZone = document.getElementById('rightZone');
    const touchpad = document.getElementById('touchpad');
    function bindZone(zone, dir){
      zone.addEventListener('pointerdown', (e)=>{ state.input[dir]=true; state.started=true; zone.setPointerCapture(e.pointerId); });
      zone.addEventListener('pointerup', ()=>{ state.input[dir]=false; });
      zone.addEventListener('pointercancel', ()=>{ state.input[dir]=false; });
      zone.addEventListener('pointerleave', ()=>{ state.input[dir]=false; });
    }
    bindZone(leftZone,'left'); bindZone(rightZone,'right');

    // Buttons & overlay
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const overlay = document.getElementById('overlay');
    const ovTitle = document.getElementById('ovTitle');
    const ovSubtitle = document.getElementById('ovSubtitle');
    const resumeBtn = document.getElementById('resumeBtn');
    const ovRestartBtn = document.getElementById('ovRestartBtn');

    pauseBtn.onclick = ()=> togglePause();
    restartBtn.onclick = ()=>{ reset(); hideOverlay(); };
    resumeBtn.onclick = ()=> togglePause(false);
    ovRestartBtn.onclick = ()=>{ reset(); hideOverlay(); };

    function showOverlay(title, subtitle, resumeVisible){
      ovTitle.textContent = title;
      ovSubtitle.textContent = subtitle;
      resumeBtn.style.display = resumeVisible ? 'inline-block' : 'none';
      overlay.style.display = 'flex';
    }
    function hideOverlay(){ overlay.style.display='none'; }

    function togglePause(force){
      if(state.gameOver) return; // can't pause when over
      const to = (typeof force==='boolean') ? force : !state.paused;
      state.paused = to;
      pauseBtn.textContent = to ? 'Resume ‚ñ∂Ô∏è' : 'Pause ‚è∏Ô∏è';
      if(to) showOverlay('Paused','Press Resume to keep jumping!', true); else hideOverlay();
    }

    function updateScoreUI(){
      document.getElementById('scoreVal').textContent = Math.floor(state.maxHeight).toString();
    }

    // GAME LOOP
    function loop(now){
      const dt = Math.min(0.032, (now - state.lastTime)/1000); // clamp dt for stability
      state.lastTime = now;

      if(!state.paused && !state.gameOver){
        update(dt);
        render();
      }
      requestAnimationFrame(loop);
    }

    function update(dt){
      const p = state.player;
      // Horizontal movement
      const target = (state.input.left? -1:0) + (state.input.right? 1:0);
      const aim = target * MOVE_MAX;
      const diff = aim - p.vx;
      const ax = Math.max(-MOVE_ACCEL, Math.min(MOVE_ACCEL, diff/dt));
      p.vx += ax * dt;
      if(Math.abs(diff) < 6) p.vx = aim; // snap near target

      p.x += p.vx * dt;

      // Wrap at edges
      const W = canvas.width/(window.devicePixelRatio||1);
      if(p.x < -p.w) p.x = W; else if(p.x > W) p.x = -p.w;

      // Vertical
      p.vy += G * dt;
      p.y += p.vy * dt;

      // Platform movement & collision
      const px = p.x + p.w*0.5;
      const py = p.y + p.h; // feet

      for(const plat of state.platforms){
        // move moving platforms
        if(plat.type==='moving'){
          plat.x += plat.dx * dt;
          if(plat.x < 8){ plat.x = 8; plat.dx *= -1; }
          if(plat.x + plat.w > W-8){ plat.x = W-8 - plat.w; plat.dx *= -1; }
        }

        // collision only when falling
        if(p.vy > 0 && !plat.broken){
          const withinX = px > plat.x && px < plat.x + plat.w;
          const withinY = (py >= plat.y) && (py <= plat.y + 12); // tolerance
          // make sure coming from above
          const prevPy = py - p.vy * dt;
          if(withinX && withinY && prevPy <= plat.y){
            if(plat.type==='fragile'){
              plat.broken = true;
              // slight crumble effect: no bounce, keep falling
            }else{
              p.vy = -JUMP_V * (plat.type==='moving' ? 1.05 : 1);
            }
          }
        }
      }

      // Camera follows up
      const screenH = canvas.height/(window.devicePixelRatio||1);
      const targetCam = Math.min(state.cameraY, p.y - screenH*0.4);
      state.cameraY = targetCam;
      state.maxHeight = Math.max(state.maxHeight, -state.cameraY|0);
      updateScoreUI();

      // Generate new platforms above
      extendPlatformsIfNeeded();

      // Game over: fell below
      if(p.y - state.cameraY > screenH + 40){
        state.gameOver = true;
        showOverlay('Game Over', `Final score: ${Math.floor(state.maxHeight)}`, false);
        pauseBtn.textContent = 'Pause ‚è∏Ô∏è';
      }
    }

    // DRAW
    function render(){
      const W = canvas.width/(window.devicePixelRatio||1);
      const H = canvas.height/(window.devicePixelRatio||1);

      // Sky background (already via CSS), add parallax stars/bubbles
      ctx.clearRect(0,0,W,H);

      // Parallax doodads
      drawParallax(W,H);

      // Translate by camera
      ctx.save();
      ctx.translate(0, -state.cameraY);

      // Platforms
      for(const plat of state.platforms){
        if(plat.broken){
          ctx.globalAlpha = 0.35;
        }
        drawPlatform(plat);
        ctx.globalAlpha = 1;
      }

      // Player
      drawPlayer(state.player);

      ctx.restore();
    }

    function drawParallax(W,H){
      const yOff = -state.cameraY * 0.4;
      ctx.save();
      ctx.translate(0, yOff);
      const rows = 7, cols = 6, spacingX = W/cols, spacingY = 180;
      ctx.globalAlpha = 0.15;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const x = c*spacingX + (r%2? spacingX*0.5: 0) + (c%2? 0:10);
          const y = -r*spacingY + (c%2? 40:0);
          ctx.beginPath();
          ctx.arc(x, y, 3 + (c%3), 0, Math.PI*2);
          ctx.fillStyle = c%2? '#ffffff' : '#e0f2fe';
          ctx.fill();
        }
      }
      ctx.restore();
    }

    function drawPlatform(p){
      const r = 8;
      const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y+p.h);
      if(p.type==='moving'){
        grad.addColorStop(0, '#a78bfa');
        grad.addColorStop(1, '#7c3aed');
      }else if(p.type==='fragile'){
        grad.addColorStop(0, '#f59e0b');
        grad.addColorStop(1, '#b45309');
      }else{
        grad.addColorStop(0, '#22d3ee');
        grad.addColorStop(1, '#0891b2');
      }

      roundRect(p.x, p.y, p.w, p.h, r);
      ctx.fillStyle = grad; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.stroke();

      // fragile crack
      if(p.type==='fragile'){
        ctx.beginPath();
        ctx.moveTo(p.x + p.w*0.2, p.y+2);
        ctx.lineTo(p.x + p.w*0.4, p.y+p.h-2);
        ctx.lineTo(p.x + p.w*0.55, p.y+2);
        ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.stroke();
      }
    }

    function roundRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function drawPlayer(p){
      // Body
      const bodyGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y+p.h);
      bodyGrad.addColorStop(0,'#fed7aa');
      bodyGrad.addColorStop(1,'#fb923c');
      roundRect(p.x, p.y, p.w, p.h, 10);
      ctx.fillStyle = bodyGrad; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.stroke();

      // Eyes
      ctx.fillStyle = '#111827';
      ctx.beginPath(); ctx.arc(p.x+p.w*0.35, p.y+p.h*0.38, 3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(p.x+p.w*0.65, p.y+p.h*0.38, 3, 0, Math.PI*2); ctx.fill();

      // Mouth
      ctx.beginPath();
      ctx.arc(p.x+p.w*0.5, p.y+p.h*0.62, 7, 0, Math.PI);
      ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 2; ctx.stroke();

      // Shadow under player (against camera)
      const sy = p.y + p.h + 10;
      ctx.globalAlpha = 0.25;
      ctx.beginPath(); ctx.ellipse(p.x+p.w*0.5, sy, 14, 4, 0, 0, Math.PI*2); ctx.fillStyle = '#0f172a'; ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Start
    reset();
    requestAnimationFrame(loop);

  })();
  
  </script>
</body>
</html>
